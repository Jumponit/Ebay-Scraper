# The_Ebae.py
# The main program
# Taylor Morris & Nich Phillips & Lindsey Titus


from ebaysdk.finding import Connection as Finding
from ebaysdk.exception import ConnectionError
from datetime import date, timedelta, datetime
from collections import Counter
import numpy as np #requires a separate pip install
import matplotlib as mpl # requires a separate pip install
mpl.use("TkAgg")
import matplotlib.pyplot as plt
import time
import socket
import Tkinter
from Tkinter import *

# agg backeend is used to create plot as a .png
#mpl.use('agg')

mean_Text = ''
med_Text = ''
category_List = []
category_Lookup = {}



# The method to parse the search response dictionary
def parseDict(dit):
    soldPrices = []
    sellDates = []
    conditions = []
    results = dit.get('searchResult')
    itemList = results.get('item')
    if (itemList != None):
        for item in itemList:
            shipInfo = item.get('shippingInfo')
            conditionInfo = item.get('condition')
            if (type(shipInfo)==dict and type(conditionInfo)==dict):
                shipServCost = shipInfo.get('shippingServiceCost')
                if (type(shipServCost)==dict):
                    shipCost = shipServCost.get('value')
                    shipping = float(shipCost)
                    sellStat = item.get('sellingStatus')
                    if (type(sellStat)==dict):
                        currentPrice = sellStat.get('convertedCurrentPrice')
                        if (type(currentPrice)==dict):
                            listInfo = item.get('listingInfo')
                            if (type(listInfo)==dict):
                                fullTime = listInfo.get('endTime')
                                times = fullTime.split('T')
                                aTime = times[0]
                                sellTime = datetime.strptime(aTime, "%Y-%m-%d")
                                print 'sellTime is %s' % sellTime
                                sellDates.append(sellTime)
                            else :
                                continue
                            priceVal = currentPrice.get('value')
                            soldAmount = float(priceVal)
                            soldPrices.append((shipping + soldAmount))
                            condition = conditionInfo.get('conditionDisplayName')
                            conditions.append(condition)
                        else :
                            continue
                    else :
                        continue
                else :
                    continue
            else :
                continue

            #
            #print "SellTime is %s" % sellTime
            #


        dataDict = dict([('soldPrices', soldPrices), ('sellDates', sellDates), ('conditions', conditions)])
        return dataDict
    else:
        print "Error, invalid item name, no results"



    #Test events
        #print len(soldPrices)
        #for x in soldPrices:
            #print x

# The function that searches via the Ebay API
# The function that searches via the Ebay API
def search(itemInfo, pageNum):
    category = itemInfo[2]
    startDate = itemInfo[1]
    item = itemInfo[0]
    try:
        api = Finding(config_file = "ebay.yaml")
        if category != None:
            api_request = {
                'keywords': item,
                'categoryId': [category],
                'itemFilter': [
                    {'name': 'SoldItemsOnly', 'value': True},
                    {'name': 'LocatedIn', 'value': 'US'},
                    {'name': 'EndTimeFrom', 'value': startDate}
                ],
                'paginationInput': [
                    {'pageNumber': pageNum}
                ]
            }
        else:
            api_request = {
                'keywords': item,
                'itemFilter': [
                    {'name': 'SoldItemsOnly', 'value': True},
                    {'name': 'LocatedIn', 'value': 'US'},
                    {'name': 'EndTimeFrom', 'value': startDate}
                ],
                'paginationInput': [
                    {'pageNumber': pageNum}
                ]
            }
        response = api.execute('findCompletedItems', api_request)
        #print response.dict()
        return response.dict()
    except ConnectionError as e:
        print(e)
        print(e.response.dict())

# Method to extend dict1 with info from dict2
def extendDict(dict1, dict2):
    keys = dict1.keys()
    for key in keys:
        dict1[key].extend(dict2[key])
    return dict1

def createDataDict(itemInfo):
    page = 1
    response = search(itemInfo, page)
    pageOutput = response.get('paginationOutput')
    pageNumbers = pageOutput.get('totalPages')
    print "Number of Pages = %s" % pageNumbers
    if (int(pageNumbers) > 1):
        print "First Search!"
        data = parseDict(response)
        page+= 1
        while page <= int(pageNumbers) and page < 100:
            print "Nap Time! Number: %s" % (page-1)
            time.sleep(3)
            if page < int(pageNumbers):
                print "OK! Next search!"
            try:
                data = extendDict(data, parseDict(search(itemInfo, page)))
            except socket.timeout:
                print "Caught a socket timeout! Moving on to next page"
            page+= 1
    else:
        data = parseDict(response)
    return data




# The function to get input from the user
def aquire(item_name, item_category):
    info = []
    time.sleep(1)
    name = item_name
    #name = raw_input('Enter the full item name you want to search: ')
    info.append(name)
    pastDate = date.today() - timedelta(days=90)
    datestr = pastDate.strftime('%Y-%m-%d') + 'T00:00:00.000Z'
    info.append(datestr)
    info.append(item_category)
    return info

def median(lst):
    lst = sorted(lst)
    if len(lst) < 1:
            return None
    if len(lst) %2 == 1:
            return lst[((len(lst)+1)/2)-1]
    else:
            return float(sum(lst[(len(lst)/2)-1:(len(lst)/2)+1]))/2.0


#The function to create the GUI
def GUI():
    global category_Lookup

    root = Tkinter.Tk()
    root.withdraw()
    item_entry = Tkinter.StringVar()

    def irun():
        item_entry = search_Box.get()
        print item_entry
        category_Select.delete(0, END)
        if item_entry != '' :
            initial_execute(item_entry)
            for cat in category_List:
                category_Select.insert(END, cat)

    def run():
        item_entry = search_Box.get()
        print item_entry
        if item_entry != '' :
            if category_Select.curselection() != None:
                execute(item_entry, category_Lookup.get(category_Select.get(ACTIVE)))
                print mean_Text
                mean_Display.config(text = str(mean_Text))
                median_Display.config(text = str(med_Text))
                plt.show()
            else:
                execute(item_entry, None)
                mean_Display.config(text = str(mean_Text))
                median_Display.config(text = str(med_Text))
                plt.show()


    main = Tkinter.Tk()
    main.wm_title("The Ebae")
    #main.tk.call('wm', 'iconbitmap', main._w, '-default', 'price_tag.ico')
    frame1 = Frame(main)
    frame1.pack()
    frame2 = Frame(main)
    frame2.pack()
    frame3 = Frame(main)
    frame3.pack()
    frame4 = Frame(main)
    frame4.pack()
    frame5 = Frame(main)
    frame5.pack(side = BOTTOM)

    header_Label = Label(frame1, text = "Ebay Price Checker", font = ("Ariel", "14"))
    header_Label.pack()

    search_Label = Label(frame1, text = "Item Name:  ")
    search_Label.pack(side = LEFT)
    search_Box = Entry(frame1, textvariable = item_entry)
    search_Box.pack(fill = Tkinter.X, expand = 1, side = RIGHT)

    category_Label = Label(frame2, text = "Category: ")
    category_Label.pack(side = LEFT)
    category_Select = Listbox(frame2, selectmode = 'SINGLE')
    category_Select.pack(side = RIGHT)

    mean_Label = Label(frame3, text = "Mean Price: ")
    mean_Label.pack(side = LEFT)
    mean_Display = Label(frame3, text = "$0.00")
    mean_Display.pack(side = RIGHT)

    median_Label = Label(frame4, text = "Median Price: ")
    median_Label.pack(side = LEFT)
    median_Display = Label(frame4, text = "$0.00")
    median_Display.pack(side = RIGHT)

    initial_search_Button = Tkinter.Button(frame5,
                                   text = "iSearch",
                                   font = ("Comic Sans MS", "10"),
                                   command = lambda: irun())
    initial_search_Button.pack(side = LEFT)
    search_Button = Tkinter.Button(frame5,
                                   text = "Search",
                                   font = ("Comic Sans MS", "10"),
                                   command = lambda: run())
    search_Button.pack(side = RIGHT)

    main.mainloop()



#The function to get the desired category from the user
def initial_execute(item_name):
    global category_List
    global category_Lookup
    pastDate = date.today() - timedelta(days=90)
    datestr = pastDate.strftime('%Y-%m-%d') + 'T00:00:00.000Z'
    try:
        api = Finding(config_file = "ebay.yaml")
        api_request = {
            'keywords': item_name,
            'itemFilter': [
                {'name': 'SoldItemsOnly', 'value': True},
                {'name': 'LocatedIn', 'value': 'US'},
                {'name': 'EndTimeFrom', 'value': datestr}
            ]
        }
        response = api.execute('findCompletedItems', api_request)
    except ConnectionError as e:
        print(e)

    results = response.dict().get('searchResult')
    itemList = results.get('item')
    catList = []
    if (itemList != None):
        for items in itemList:
            catList.append(items.get('primaryCategory').get('categoryName'))
            #if items.get('primaryCategory').get('categoryName') not in category_Lookup:
            category_Lookup[items.get('primaryCategory').get('categoryName')] \
                = items.get('primaryCategory').get('categoryId')

    catDict = Counter(catList)
    category_List = sorted(catDict, key = catDict.__getitem__)
    category_List.reverse()

#The main execution of the search
def execute(item_name, item_category):
    global mean_Text
    global med_Text

    itemInfo = aquire(item_name, item_category)
    itemData = createDataDict(itemInfo)
    priceList = itemData.get('soldPrices')
    print "Number of entries found: %s" % len(priceList)
    mean = sum(priceList)/float(len(priceList))
    mean_Text = "${0:.2f}".format(mean)
    print "The mean of the list is: $" + "{0:.2f}".format(mean)
    med = median(priceList)
    med_Text = "${0:.2f}".format(med)
    print "The median of the list is: $" + "{0:.2f}".format(med)
    sd = np.std(priceList)
    print "The standard deviation of the list is: $" + "{0:.2f}".format(sd)
    fig = plt.figure(1, figsize=(9,6)) # create a figure object
    fig.suptitle("Box Plot and Histogram of %s Price Data Over Past 90 Days" % itemInfo[0])
    ax = fig.add_subplot(311) # add a subplot to the figure object
    ax.boxplot(priceList, notch=True, vert=False, showmeans=True)
    binNumber = len(priceList)/10
    plt.subplot(312)
    plt.hist(priceList, bins=binNumber, normed=True, histtype = 'step')
    plt.subplot(313)
    x = mpl.dates.date2num(itemData.get('sellDates'))
    y = priceList
    plt.plot_date(x, y)



GUI()

